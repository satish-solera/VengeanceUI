{
    "$schema": "https://ui.shadcn.com/schema/registry-item.json",
    "name": "pixelated-image-trail",
    "type": "registry:ui",
    "dependencies": [],
    "files": [
        {
            "path": "components/ui/pixelated-image-trail.tsx",
            "content": "\"use client\";\n\nimport { useEffect, useRef, useState } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { cn } from \"@/lib/utils\";\n\ninterface TrailConfig {\n    imageLifespan: number;\n    inDuration: number;\n    outDuration: number;\n    staggerIn: number;\n    staggerOut: number;\n    slideDuration: number;\n    slideEasing: string;\n    easing: string;\n}\n\nexport interface PixelatedImageTrailProps {\n    className?: string;\n    images?: string[];\n    config?: Partial<TrailConfig>;\n    slices?: number;\n    spawnThreshold?: number;\n    smoothing?: number;\n}\n\nexport function PixelatedImageTrail({\n    className,\n    images = [],\n    config: configOverride = {},\n    slices = 10,\n    spawnThreshold = 12,\n    smoothing = 0.35,\n}: PixelatedImageTrailProps) {\n    const [mounted, setMounted] = useState(false);\n    const trailContainerRef = useRef<HTMLDivElement>(null);\n    const currentImageIndexRef = useRef(0);\n    const mousePosRef = useRef({ x: 0, y: 0 });\n    const lastMousePosRef = useRef({ x: 0, y: 0 });\n    const interpolatedMousePosRef = useRef({ x: 0, y: 0 });\n    const animationFrameRef = useRef<number | null>(null);\n\n    useEffect(() => {\n        setMounted(true);\n    }, []);\n\n    useEffect(() => {\n        if (!mounted) return;\n\n        const defaultConfig: TrailConfig = {\n            imageLifespan: 700,\n            inDuration: 400,\n            outDuration: 500,\n            staggerIn: 18,\n            staggerOut: 12,\n            slideDuration: 450,\n            slideEasing: \"cubic-bezier(0.22, 1, 0.36, 1)\",\n            easing: \"cubic-bezier(0.25, 1, 0.5, 1)\",\n        };\n\n        const config = { ...defaultConfig, ...configOverride };\n        const trailImageCount = 5;\n        const finalImages = images.length > 0 ? images : Array.from(\n            { length: trailImageCount },\n            (_, i) => `/trail-images/image${i + 1}.jpg`\n        );\n\n        finalImages.forEach(src => {\n            const img = new Image();\n            img.src = src;\n        });\n\n        const trailContainer = trailContainerRef.current;\n        if (!trailContainer) return;\n\n        const MathUtils = {\n            lerp: (a: number, b: number, n: number) => (1 - n) * a + n * b,\n            distance: (x1: number, y1: number, x2: number, y2: number) =>\n                Math.hypot(x2 - x1, y2 - y1),\n        };\n\n        const getMouseDistance = () =>\n            MathUtils.distance(\n                interpolatedMousePosRef.current.x,\n                interpolatedMousePosRef.current.y,\n                lastMousePosRef.current.x,\n                lastMousePosRef.current.y\n            );\n\n        const createTrailImage = () => {\n            const imgContainer = document.createElement(\"div\");\n            imgContainer.classList.add(\"pixelated-trail-img\");\n\n            const imgSrc = finalImages[currentImageIndexRef.current];\n            currentImageIndexRef.current =\n                (currentImageIndexRef.current + 1) % finalImages.length;\n\n            const rect = trailContainer.getBoundingClientRect();\n            const startX = interpolatedMousePosRef.current.x - rect.left - 87.5;\n            const startY = interpolatedMousePosRef.current.y - rect.top - 87.5;\n\n            const dx = mousePosRef.current.x - interpolatedMousePosRef.current.x;\n            const dy = mousePosRef.current.y - interpolatedMousePosRef.current.y;\n\n            const targetX = startX + dx * 0.5;\n            const targetY = startY + dy * 0.5;\n\n            const rotation = Math.random() * 12 - 6;\n            imgContainer.style.transform = `rotate(${rotation}deg) translate3d(0, 0, 0)`;\n            imgContainer.style.left = `${startX}px`;\n            imgContainer.style.top = `${startY}px`;\n            imgContainer.style.transition = `left ${config.slideDuration}ms ${config.slideEasing}, top ${config.slideDuration}ms ${config.slideEasing}, opacity 200ms ease-out`;\n\n            const maskLayers: HTMLDivElement[] = [];\n\n            for (let i = 0; i < slices; i++) {\n                const layer = document.createElement(\"div\");\n                layer.classList.add(\"pixelated-mask-layer\");\n\n                const imageLayer = document.createElement(\"div\");\n                imageLayer.classList.add(\"pixelated-image-layer\");\n                imageLayer.style.backgroundImage = `url(${imgSrc})`;\n\n                const sliceSize = 100 / slices;\n                const startClipY = i * sliceSize;\n                const endClipY = (i + 1) * sliceSize;\n\n                layer.style.clipPath = `polygon(50% ${startClipY}%, 50% ${startClipY}%, 50% ${endClipY}%, 50% ${endClipY}%)`;\n                layer.style.transition = `clip-path ${config.inDuration}ms ${config.easing}`;\n                layer.style.transform = \"translate3d(0, 0, 0)\";\n                layer.style.backfaceVisibility = \"hidden\";\n\n                layer.appendChild(imageLayer);\n                imgContainer.appendChild(layer);\n                maskLayers.push(layer);\n            }\n\n            trailContainer.appendChild(imgContainer);\n\n            requestAnimationFrame(() => {\n                imgContainer.style.left = `${targetX}px`;\n                imgContainer.style.top = `${targetY}px`;\n\n                maskLayers.forEach((layer, i) => {\n                    const sliceSize = 100 / slices;\n                    const startClipY = i * sliceSize;\n                    const endClipY = (i + 1) * sliceSize;\n                    const distanceFromMiddle = Math.abs(i - (slices - 1) / 2);\n                    const delay = distanceFromMiddle * config.staggerIn;\n\n                    setTimeout(() => {\n                        layer.style.clipPath = `polygon(0% ${startClipY}%, 100% ${startClipY}%, 100% ${endClipY}%, 0% ${endClipY}%)`;\n                    }, delay);\n                });\n            });\n\n            setTimeout(() => {\n                if (config.outDuration > 0) {\n                    maskLayers.forEach((layer, i) => {\n                        const distanceFromMiddle = Math.abs(i - (slices - 1) / 2);\n                        const delay = distanceFromMiddle * config.staggerOut;\n                        setTimeout(() => {\n                            const sliceSize = 100 / slices;\n                            const startClipY = i * sliceSize;\n                            const endClipY = (i + 1) * sliceSize;\n                            layer.style.clipPath = `polygon(50% ${startClipY}%, 50% ${startClipY}%, 50% ${endClipY}%, 50% ${endClipY}%)`;\n                        }, delay);\n                    });\n\n                    setTimeout(() => {\n                        if (imgContainer.parentElement === trailContainer) {\n                            trailContainer.removeChild(imgContainer);\n                        }\n                    }, config.outDuration + (slices * config.staggerOut) + 100);\n                } else {\n                    if (imgContainer.parentElement === trailContainer) {\n                        trailContainer.removeChild(imgContainer);\n                    }\n                }\n            }, config.imageLifespan);\n        };\n\n        const handleMouseMove = (e: MouseEvent) => {\n            mousePosRef.current = { x: e.clientX, y: e.clientY };\n        };\n\n        const render = () => {\n            interpolatedMousePosRef.current.x = MathUtils.lerp(\n                interpolatedMousePosRef.current.x,\n                mousePosRef.current.x,\n                smoothing\n            );\n            interpolatedMousePosRef.current.y = MathUtils.lerp(\n                interpolatedMousePosRef.current.y,\n                mousePosRef.current.y,\n                smoothing\n            );\n\n            if (getMouseDistance() > spawnThreshold) {\n                lastMousePosRef.current = { ...interpolatedMousePosRef.current };\n                createTrailImage();\n            }\n\n            animationFrameRef.current = requestAnimationFrame(render);\n        };\n\n        window.addEventListener(\"mousemove\", handleMouseMove);\n        animationFrameRef.current = requestAnimationFrame(render);\n\n        const initMouse = (e: MouseEvent) => {\n            mousePosRef.current = { x: e.clientX, y: e.clientY };\n            interpolatedMousePosRef.current = { x: e.clientX, y: e.clientY };\n            lastMousePosRef.current = { x: e.clientX, y: e.clientY };\n            window.removeEventListener(\"mousemove\", initMouse);\n        }\n        window.addEventListener(\"mousemove\", initMouse, { once: true });\n\n        return () => {\n            window.removeEventListener(\"mousemove\", handleMouseMove);\n            if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);\n        };\n    }, [mounted, configOverride, slices, spawnThreshold, smoothing, JSON.stringify(images)]);\n\n    if (!mounted) return null;\n\n    return createPortal(\n        <div className={cn(\"pixelated-trail-container\", className)} ref={trailContainerRef}></div>,\n        document.body\n    );\n}\n\nexport default PixelatedImageTrail;\n",
            "type": "registry:ui",
            "target": "components/ui/pixelated-image-trail.tsx"
        }
    ],
    "cssVars": {
        "light": {},
        "dark": {}
    },
    "css": "/* Pixelated Image Trail - Premium GPU Optimized */\n\n.pixelated-trail-container {\n    position: fixed;\n    inset: 0;\n    width: 100vw;\n    height: 100vh;\n    pointer-events: none;\n    z-index: 9999;\n    overflow: hidden;\n    transform: translate3d(0, 0, 0);\n    contain: strict;\n    perspective: 1000px;\n}\n\n.pixelated-trail-img {\n    position: absolute;\n    width: 175px;\n    height: 175px;\n    pointer-events: none;\n    transform: translate3d(0, 0, 0);\n    will-change: transform, left, top;\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n    contain: layout style paint;\n    filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));\n    opacity: 0.98;\n}\n\n.pixelated-mask-layer {\n    position: absolute;\n    inset: 0;\n    transform: translate3d(0, 0, 0);\n    will-change: clip-path;\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n    isolation: isolate;\n    contain: layout style;\n}\n\n.pixelated-image-layer {\n    position: absolute;\n    inset: 0;\n    background-size: cover;\n    background-position: center;\n    border-radius: 10px;\n    transform: translate3d(0, 0, 0);\n    backface-visibility: hidden;\n    image-rendering: auto;\n    image-rendering: -webkit-optimize-contrast;\n    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);\n}\n\n@media (prefers-reduced-motion: reduce) {\n    .pixelated-trail-container {\n        display: none;\n    }\n}"
}