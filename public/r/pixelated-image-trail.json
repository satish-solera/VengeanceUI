{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixelated-image-trail",
  "type": "registry:ui",
  "dependencies": [],
  "files": [
    {
      "path": "components/ui/pixelated-image-trail.tsx",
      "content": "\"use client\";\r\n\r\nimport { useEffect, useRef, useState } from \"react\";\r\nimport { createPortal } from \"react-dom\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\n/**\r\n * Configuration options for the pixelated image trail effect\r\n */\r\ninterface TrailConfig {\r\n    /** Duration (ms) before an image starts fading out */\r\n    imageLifespan: number;\r\n    /** Duration (ms) of the reveal animation */\r\n    inDuration: number;\r\n    /** Duration (ms) of the hide animation */\r\n    outDuration: number;\r\n    /** Stagger delay (ms) for slices during reveal */\r\n    staggerIn: number;\r\n    /** Stagger delay (ms) for slices during hide */\r\n    staggerOut: number;\r\n    /** Duration (ms) of the slide animation */\r\n    slideDuration: number;\r\n    /** CSS easing function for slide animation */\r\n    slideEasing: string;\r\n    /** CSS easing function for mask animations */\r\n    easing: string;\r\n}\r\n\r\n/**\r\n * Props for the PixelatedImageTrail component\r\n */\r\nexport interface PixelatedImageTrailProps {\r\n    /** Additional CSS classes for the trail container */\r\n    className?: string;\r\n    /** Array of image URLs to cycle through */\r\n    images?: string[];\r\n    /** Override partial configuration options */\r\n    config?: Partial<TrailConfig>;\r\n    /** Number of horizontal slices (affects pixelation effect) */\r\n    slices?: number;\r\n    /** Distance threshold for spawning new trail images */\r\n    spawnThreshold?: number;\r\n    /** Interpolation factor for mouse smoothing (0-1) */\r\n    smoothing?: number;\r\n}\r\n\r\n/**\r\n * PixelatedImageTrail - A stunning hover effect that creates a trail of pixelated images\r\n * following the cursor. Images reveal with a slice-based animation creating a \r\n * premium, dynamic visual effect.\r\n * \r\n * @example\r\n * ```tsx\r\n * <PixelatedImageTrail\r\n *   images={['/image1.jpg', '/image2.jpg', '/image3.jpg']}\r\n *   config={{ imageLifespan: 1200, staggerIn: 40 }}\r\n * />\r\n * ```\r\n */\r\nexport function PixelatedImageTrail({\r\n    className,\r\n    images = [],\r\n    config: configOverride = {},\r\n    slices = 4,\r\n    spawnThreshold = 100,\r\n    smoothing = 0.1,\r\n}: PixelatedImageTrailProps) {\r\n    const [mounted, setMounted] = useState(false);\r\n    const trailContainerRef = useRef<HTMLDivElement>(null);\r\n    const currentImageIndexRef = useRef(0);\r\n    const mousePosRef = useRef({ x: 0, y: 0 });\r\n    const lastMousePosRef = useRef({ x: 0, y: 0 });\r\n    const interpolatedMousePosRef = useRef({ x: 0, y: 0 });\r\n    const animationFrameRef = useRef<number | null>(null);\r\n    const validImagesRef = useRef<string[]>([]);\r\n\r\n    const trailImageCount = 3;\r\n    const finalImages = images.length > 0 ? images : Array.from(\r\n        { length: trailImageCount },\r\n        (_, i) => `/trail-images/image${i + 1}.jpg`\r\n    );\r\n\r\n    // Preload images and only use them once loaded\r\n    useEffect(() => {\r\n        validImagesRef.current = [];\r\n        finalImages.forEach(src => {\r\n            const img = new Image();\r\n            img.src = src;\r\n            img.onload = () => {\r\n                validImagesRef.current.push(src);\r\n            };\r\n        });\r\n    }, [JSON.stringify(finalImages)]);\r\n\r\n    useEffect(() => {\r\n        setMounted(true);\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (!mounted) return;\r\n\r\n        // Default configuration - Codrops-optimized timing\r\n        const defaultConfig: TrailConfig = {\r\n            imageLifespan: 400,\r\n            inDuration: 150,\r\n            outDuration: 300,\r\n            staggerIn: 6,\r\n            staggerOut: 4,\r\n            slideDuration: 900,\r\n            slideEasing: \"cubic-bezier(0.16, 1, 0.3, 1)\", // Expo.easeOut\r\n            easing: \"cubic-bezier(0.16, 1, 0.3, 1)\",\r\n        };\r\n\r\n        const config = { ...defaultConfig, ...configOverride };\r\n\r\n        const trailContainer = trailContainerRef.current;\r\n        if (!trailContainer) return;\r\n\r\n        // Math utilities for smooth interpolation\r\n        const MathUtils = {\r\n            lerp: (a: number, b: number, n: number) => (1 - n) * a + n * b,\r\n            distance: (x1: number, y1: number, x2: number, y2: number) =>\r\n                Math.hypot(x2 - x1, y2 - y1),\r\n        };\r\n\r\n        const getMouseDistance = () =>\r\n            MathUtils.distance(\r\n                interpolatedMousePosRef.current.x,\r\n                interpolatedMousePosRef.current.y,\r\n                lastMousePosRef.current.x,\r\n                lastMousePosRef.current.y\r\n            );\r\n\r\n        /**\r\n         * Creates a trail image element with pixelated slice animation\r\n         */\r\n        const createTrailImage = () => {\r\n            // Skip if no images are loaded yet to prevent glitches\r\n            if (validImagesRef.current.length === 0) return;\r\n\r\n            const imgContainer = document.createElement(\"div\");\r\n            imgContainer.classList.add(\"pixelated-trail-img\");\r\n\r\n            // Use only valid loaded images\r\n            const imgSrc = validImagesRef.current[currentImageIndexRef.current % validImagesRef.current.length];\r\n            currentImageIndexRef.current = (currentImageIndexRef.current + 1) % validImagesRef.current.length;\r\n\r\n            const rect = trailContainer.getBoundingClientRect();\r\n            // ... rest of function ...\r\n            const startX = interpolatedMousePosRef.current.x - rect.left - 87.5;\r\n            const startY = interpolatedMousePosRef.current.y - rect.top - 87.5;\r\n\r\n            const dx = mousePosRef.current.x - interpolatedMousePosRef.current.x;\r\n            const dy = mousePosRef.current.y - interpolatedMousePosRef.current.y;\r\n\r\n            const targetX = startX + dx * 0.5;\r\n            const targetY = startY + dy * 0.5;\r\n\r\n            // Codrops doesn't use specific rotation, just proper placement\r\n            // We keep it simple: translate only, no rotation or scale-in\r\n            imgContainer.style.transform = `translate3d(0, 0, 0)`;\r\n\r\n            imgContainer.style.left = `${startX}px`;\r\n            imgContainer.style.top = `${startY}px`;\r\n            imgContainer.style.transition = `left ${config.slideDuration}ms ${config.slideEasing}, top ${config.slideDuration}ms ${config.slideEasing}`;\r\n\r\n            const maskLayers: HTMLDivElement[] = [];\r\n\r\n            // Create sliced layers for pixelation effect\r\n            for (let i = 0; i < slices; i++) {\r\n                const layer = document.createElement(\"div\");\r\n                layer.classList.add(\"pixelated-mask-layer\");\r\n\r\n                const imageLayer = document.createElement(\"div\");\r\n                imageLayer.classList.add(\"pixelated-image-layer\");\r\n                imageLayer.style.backgroundImage = `url(${imgSrc})`;\r\n\r\n                const sliceSize = 100 / slices;\r\n                const startClipY = i * sliceSize;\r\n                const endClipY = (i + 1) * sliceSize;\r\n\r\n                // Initial collapsed clip-path (hidden)\r\n                layer.style.clipPath = `polygon(50% ${startClipY}%, 50% ${startClipY}%, 50% ${endClipY}%, 50% ${endClipY}%)`;\r\n                layer.style.transition = `clip-path ${config.inDuration}ms ${config.easing}`;\r\n                layer.style.transform = \"translateZ(0)\";\r\n                layer.style.backfaceVisibility = \"hidden\";\r\n\r\n                layer.appendChild(imageLayer);\r\n                imgContainer.appendChild(layer);\r\n                maskLayers.push(layer);\r\n            }\r\n\r\n            trailContainer.appendChild(imgContainer);\r\n\r\n            // Animate in with staggered slice reveal + scale pop\r\n            requestAnimationFrame(() => {\r\n                imgContainer.style.left = `${targetX}px`;\r\n                imgContainer.style.top = `${targetY}px`;\r\n                // No rotation or scale change on enter - just position\r\n                imgContainer.style.transform = `translate3d(0, 0, 0)`;\r\n\r\n                maskLayers.forEach((layer, i) => {\r\n                    const sliceSize = 100 / slices;\r\n                    const startClipY = i * sliceSize;\r\n                    const endClipY = (i + 1) * sliceSize;\r\n\r\n                    // Ripple stagger from center outwards\r\n                    const distanceFromMiddle = Math.abs(i - (slices - 1) / 2);\r\n                    const delay = distanceFromMiddle * config.staggerIn;\r\n\r\n                    setTimeout(() => {\r\n                        layer.style.clipPath = `polygon(0% ${startClipY}%, 100% ${startClipY}%, 100% ${endClipY}%, 0% ${endClipY}%)`;\r\n                    }, delay);\r\n                });\r\n            });\r\n\r\n            // Animate out - Codrops style fade + scale down\r\n            setTimeout(() => {\r\n                // Use CSS class for reliable exit transition\r\n                imgContainer.classList.add(\"animate-out\");\r\n\r\n                // Remove from DOM after fade completes\r\n                setTimeout(() => {\r\n                    if (imgContainer.parentElement === trailContainer) {\r\n                        trailContainer.removeChild(imgContainer);\r\n                    }\r\n                }, config.outDuration);\r\n            }, config.imageLifespan);\r\n        };\r\n\r\n        const handleMouseMove = (e: MouseEvent) => {\r\n            mousePosRef.current = { x: e.clientX, y: e.clientY };\r\n        };\r\n\r\n        /**\r\n         * Animation loop with smooth mouse interpolation\r\n         */\r\n        const render = () => {\r\n            interpolatedMousePosRef.current.x = MathUtils.lerp(\r\n                interpolatedMousePosRef.current.x,\r\n                mousePosRef.current.x,\r\n                smoothing\r\n            );\r\n            interpolatedMousePosRef.current.y = MathUtils.lerp(\r\n                interpolatedMousePosRef.current.y,\r\n                mousePosRef.current.y,\r\n                smoothing\r\n            );\r\n\r\n            if (getMouseDistance() > spawnThreshold) {\r\n                lastMousePosRef.current = { ...interpolatedMousePosRef.current };\r\n                createTrailImage();\r\n            }\r\n\r\n            animationFrameRef.current = requestAnimationFrame(render);\r\n        };\r\n\r\n        window.addEventListener(\"mousemove\", handleMouseMove);\r\n        animationFrameRef.current = requestAnimationFrame(render);\r\n\r\n        // Initialize mouse position on first move\r\n        const initMouse = (e: MouseEvent) => {\r\n            mousePosRef.current = { x: e.clientX, y: e.clientY };\r\n            interpolatedMousePosRef.current = { x: e.clientX, y: e.clientY };\r\n            lastMousePosRef.current = { x: e.clientX, y: e.clientY };\r\n            window.removeEventListener(\"mousemove\", initMouse);\r\n        }\r\n        window.addEventListener(\"mousemove\", initMouse, { once: true });\r\n\r\n\r\n        return () => {\r\n            window.removeEventListener(\"mousemove\", handleMouseMove);\r\n            if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);\r\n        };\r\n    }, [mounted, configOverride, slices, spawnThreshold, smoothing, JSON.stringify(images)]);\r\n\r\n    if (!mounted) return null;\r\n\r\n    return createPortal(\r\n        <div className={cn(\"pixelated-trail-container\", className)} ref={trailContainerRef}></div>,\r\n        document.body\r\n    );\r\n}\r\n\r\nexport default PixelatedImageTrail;\r\n",
      "type": "registry:ui",
      "target": "components/ui/pixelated-image-trail.tsx"
    }
  ]
}